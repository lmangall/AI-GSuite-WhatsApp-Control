import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  let app;
  
  try {
    app = await NestFactory.create(AppModule);
    
    // Enable graceful shutdown hooks
    app.enableShutdownHooks();
    
    const port = process.env.PORT || 80;
    await app.listen(port, '0.0.0.0');
    
    logger.log(`ðŸš€ Application is running on: http://0.0.0.0:${port}`);
    logger.log(`ðŸ“¨ Webhook endpoint: http://0.0.0.0:${port}/webhook`);
    
    // Handle uncaught exceptions
    process.on('uncaughtException', (error) => {
      logger.error(`Uncaught Exception: ${error.message}`, error.stack);
    });
    
    // Handle unhandled promise rejections
    process.on('unhandledRejection', (reason) => {
      logger.error(`Unhandled Rejection: ${reason}`);
    });
    
    // Handle process termination signals
    const signals = ['SIGINT', 'SIGTERM'];
    signals.forEach((signal) => {
      process.on(signal, async () => {
        logger.log(`Received ${signal}. Gracefully shutting down...`);
        if (app) {
          await app.close();
        }
        process.exit(0);
      });
    });
    
  } catch (error) {
    logger.error(`Failed to start application: ${error.message}`, error.stack);
    if (app) {
      await app.close();
    }
    process.exit(1);
  }
}

bootstrap();
import { Body, Controller, Get, Post, Query } from '@nestjs/common';
import { MCPService } from './mcp.service';

type ToolResponse = any; // Replace with proper type from your SDK

@Controller('mcp')
export class MCPController {
  constructor(private readonly mcpService: MCPService) {}

  // GET endpoint for simple queries (tool name only)
  @Get('call')
  async callToolGet(
    @Query('name') name: string,
  ): Promise<ToolResponse | { error: string }> {
    if (!name) return { error: 'Tool name is required' };
    return this.mcpService.callTool(name);
  }

  // POST endpoint for full JSON body with args
  @Post()
  async callToolPost(@Body() body: { name: string; args?: any }): Promise<ToolResponse> {
    if (!body.name) throw new Error('Tool name is required');
    return this.mcpService.callTool(body.name, body.args);
  }
}
import { Module } from '@nestjs/common';
import { MCPService } from './mcp.service';
import { MCPController } from './mcp.controller';

@Module({
  providers: [MCPService],
  controllers: [MCPController],
  exports: [MCPService],
})
export class MCPModule {}
import { Inject, Injectable, OnModuleDestroy, OnModuleInit, Logger } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';
import { CallToolRequest, CallToolResultSchema } from '@modelcontextprotocol/sdk/types.js';

type ToolResponse = any; // Replace with proper type from your SDK

@Injectable()
export class MCPService implements OnModuleInit, OnModuleDestroy {
  private readonly logger = new Logger(MCPService.name);
  private client: Client;
  private transport: StreamableHTTPClientTransport;
  private serverUrl: string;
  private sessionId?: string;

  constructor(private configService: ConfigService) {
    this.serverUrl = this.configService.get<string>('MCP_SERVER_URL');
    if (!this.serverUrl) {
      throw new Error('MCP_SERVER_URL is not defined in environment variables');
    }
  }

  async onModuleInit() {
    await this.connect();
  }

  async onModuleDestroy() {
    await this.disconnect();
  }

  async connect(): Promise<void> {
    this.logger.log(`Connecting to MCP server at ${this.serverUrl}...`);

    try {
      this.client = new Client(
        { name: 'nestjs-client', version: '1.0.0' },
        { capabilities: { elicitation: {} } }
      );

      this.transport = new StreamableHTTPClientTransport(new URL(this.serverUrl), {
        sessionId: this.sessionId,
      });

      this.client.onerror = (err) => this.logger.error('Client error:', err);

      await this.client.connect(this.transport);
      this.sessionId = this.transport.sessionId;

      this.logger.log(`Connected to MCP server, session ID: ${this.sessionId}`);
    } catch (error) {
      this.logger.error('Failed to connect to MCP server:', error);
      throw new Error(`Failed to connect to MCP server: ${error.message}`);
    }
  }

  async disconnect(): Promise<void> {
    if (!this.client || !this.transport) return;
    
    try {
      await this.transport.close();
      this.logger.log('Disconnected from MCP server');
    } catch (error) {
      this.logger.error('Error disconnecting from MCP server:', error);
      throw new Error(`Error disconnecting from MCP server: ${error.message}`);
    }
  }

  async callTool(name: string, args: Record<string, unknown> = {}): Promise<ToolResponse> {
    if (!this.client) {
      throw new Error('Not connected to MCP server');
    }

    try {
      const request: CallToolRequest = {
        method: 'tools/call',
        params: { name, arguments: args },
      };
      
      this.logger.debug(`Calling tool: ${name}`, { args });
      const result = await this.client.request(request, CallToolResultSchema);
      this.logger.debug(`Tool ${name} result:`, { result });
      
      return result as ToolResponse;
    } catch (error) {
      this.logger.error(`Error calling tool ${name}:`, error);
      throw new Error(`Failed to call tool ${name}: ${error.message}`);
    }
  }
}
